I"ô&<p>Vous souhaitez commencer Ã  utiliser les super technos dâ€™aujourdâ€™hui comme <strong>React</strong>?</p>

<blockquote>
  <p>Et bien , il faut vous familiarisÃ© avec les nouvelles nouvelles avancÃ©es en <strong>JavaScript</strong>. Ces avancÃ©es sont apparues Ã  partir de <strong>2015</strong>, dans la version du langage <em>appelÃ©e ES2015 (Ã©galement connue sous le nom Â« ES6 Â»).</em></p>
</blockquote>

<p>Peut-Ãªtre nâ€™avez-vous pas lâ€™habitude de cette syntaxe : nous allons donc jeter un rapide coup dâ€™Å“il sur les principales nouveautÃ©s que vous rencontrerez frÃ©quemment Ã  lâ€™usage.</p>

<h1 id="classes">Classes</h1>

<p><em>Les composants React</em> peuvent Ãªtre dÃ©finis sous forme de <strong>fonctions ou de classes</strong>. <strong>ES2015</strong> fournit du <em>Â« sucre syntaxique Â»</em> qui facilite considÃ©rablement la dÃ©finition de classes, comparÃ©e Ã  lâ€™approche traditionnelle en JavaScript.</p>

<blockquote>
  <p>Si vous venez dâ€™un autre langage, POO , voir le  mot clÃ© <code class="highlighter-rouge">Class</code> vous font peut-Ãªtre dire, â€œah, JavaScript est enfin un langage orientÃ© objet..â€ DÃ©tromper-vous, il lâ€™a toujours Ã©tÃ© , et mÃªme plus que <code class="highlighter-rouge">Java</code>. Brefâ€¦
Sachez juste quâ€™en POO, on manipule des objets qui reprÃ©sentent des entitÃ©s de notre programme (des composants, des documents, des utilisateursâ€¦), et quâ€™une classe est en quelque sorte le plan de construction pour une catÃ©gorie dâ€™objets (et lâ€™usine qui les fabrique).</p>
</blockquote>

<p>Cette syntaxe est comparable Ã  celle trouvÃ©e dans de nombreux langages courants. Voici un exemple :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Account</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="na">loginState</span><span class="p">:</span> <span class="dl">'</span><span class="s1">logged-out</span><span class="dl">'</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// â€¦</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Faites attention aux points suivants :</p>

<ul>
  <li>
    <p>Le mot-clÃ©  <code class="highlighter-rouge">class</code>  permet de dÃ©finir un <strong>corps de classe</strong>, dont les Ã©lÃ©ments (constructeur, mÃ©thodes, etc.) nâ€™ont pas besoin dâ€™Ãªtre sÃ©parÃ©s par des virgules, contrairement Ã  ce qui se passe dans les littÃ©raux objets.</p>
  </li>
  <li>
    <p>Il est facile de spÃ©cialiser une classe par hÃ©ritage Ã  lâ€™aide du mot-clÃ© <code class="highlighter-rouge">extends</code></p>
  </li>
  <li>
    <p>Le mot-clÃ©  <code class="highlighter-rouge">constructor</code>  permet de dÃ©finir le constructeur de la classe ; au sein du constructeur,  <code class="highlighter-rouge">super(â€¦)</code>  permet dâ€™appeler le constructeur hÃ©ritÃ©, ce qui est dâ€™ailleurs <strong>obligatoire</strong> si la classe en spÃ©cialise une autre avec <code class="highlighter-rouge">extends</code>  (et doit impÃ©rativement prÃ©cÃ©der toute manipulation de <code class="highlighter-rouge">this</code> ).</p>
  </li>
</ul>

<blockquote>
  <p><strong>Notez bien :</strong> si vous Ã©crivez une classe qui en spÃ©cialise une autre avec  <code class="highlighter-rouge">extends</code> , et que votre classe a son propre constructeur, celui-ci doit impÃ©rativement appeler le constructeur parent avec  <code class="highlighter-rouge">super(â€¦)</code> , et ce avant de manipuler  <code class="highlighter-rouge">this</code>  de quelque faÃ§on que ce soit.
Câ€™est une obligation syntaxique dans la spec : votre code JavaScript ne devrait pas Ãªtre valide sans cela. En pratique, la plupart des moteurs JS (hors Babel, qui justement tourne Â« sous le capot Â» dans Create React App et dans la plupart des projets) attendront lâ€™invocation du  <code class="highlighter-rouge">new</code>  pour dÃ©tecter le souci, et lever une  <code class="highlighter-rouge">ReferenceError</code>  plutÃ´t quâ€™une  <code class="highlighter-rouge">SyntaxError</code>. En tous les cas, Ã§a ne marchera pas <em>in fine.</em></p>
</blockquote>

<ul>
  <li>Les mÃ©thodes doivent Ãªtre dÃ©clarÃ©es avec la nouvelle syntaxe de Â« mÃ©thodes concises Â», Ã©galement disponible dans les littÃ©raux objets :  <code class="highlighter-rouge">nom (paramÃ¨tres) { â€¦ }</code> , contrairement Ã  ce que lâ€™on faisait auparavant dans les littÃ©raux objets, comme par exemple   nom: <code class="highlighter-rouge">function (paramÃ¨tres) { â€¦ } </code>.</li>
</ul>

<p>Et parce que la Documentation , câ€™est la vie , câ€™est <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Classes">par ici</a></p>

<h1 id="fonctions-flÃ©chÃ©es">Fonctions flÃ©chÃ©es</h1>

<p>Une syntaxe plus concise</p>

<p>Le premier avantage des fonctions flÃ©chÃ©es est la concision de leur syntaxe.</p>

<p>Traditionnellement, une fonction se dÃ©clare avec le mot-clÃ©  <code class="highlighter-rouge">function</code>  suivi de la signature puis du bloc de fonction, au sein duquel tout  <code class="highlighter-rouge">return</code>  doit Ãªtre explicite. Par exemple :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">adults</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">minors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nx">people</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">adults</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="nx">minors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
   <span class="p">})</span>

<span class="nx">people</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">person</span><span class="p">.</span><span class="nx">firstName</span>
<span class="p">})</span>

</code></pre></div></div>
<p>Les fonctions flÃ©chÃ©es ne nÃ©cessitent pas de mot-clÃ© dÃ©claratif. Lorsquâ€™elles sont intÃ©gralement constituÃ©es dâ€™une expression Ã  renvoyer, les accolades du bloc de fonction peuvent Ãªtre omises,  ainsi que le mot-clÃ© <code class="highlighter-rouge">return</code> .</p>

<p>Entre la signature et le bloc ou lâ€™expression, on trouve une <em>fat arrow</em> (un nom bien naze!) , Ã  savoir  <code class="highlighter-rouge">=&gt;</code></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">adults</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">minors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nx">people</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">person</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">adults</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">minors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="nx">people</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">person</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">person</span><span class="p">.</span><span class="nx">firstName</span><span class="p">)</span>

</code></pre></div></div>
<p>Câ€™est une syntaxe raccourcie trÃ¨s pratique pour les <strong>prÃ©dicats</strong> (fonctions qui renvoient vrai ou faux selon leurs arguments, et qui sont par exemple passÃ©es aux mÃ©thodes <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">every</code>  et  <code class="highlighter-rouge">some</code>) et les mappers (fonctions de transformation telles que celles passÃ©es Ã   map ). Dans ce deuxiÃ¨me cas, elles seront par exemple trÃ¨s utiles pour Â« rÃ©duire le bruit Â» dans les mÃ©thodes  render  de nos composants React.</p>
:ET