I"×K<p>Tu souhaites dÃ©buter avec les super technos dâ€™aujourdâ€™hui comme <strong>React</strong>?</p>

<blockquote>
  <p>Et bien , il faut te familiarisÃ© avec les nouvelles avancÃ©es en <strong>JavaScript</strong>. Ces avancÃ©es sont apparues Ã  partir de <strong>2015</strong>, dans la version du langage <em>appelÃ©e ES2015 (Ã©galement connue sous le nom Â« ES6 Â»).</em></p>
</blockquote>

<p>Peut-Ãªtre nâ€™as tu tout simplement pas lâ€™habitude de cette syntaxe : nous allons donc jeter un rapide coup dâ€™Å“il sur les principales nouveautÃ©s que vous rencontrerez frÃ©quemment Ã  lâ€™usage.</p>

<h1 id="classes">Classes</h1>

<p><em>Les composants React</em> peuvent Ãªtre dÃ©finis sous forme de <strong>fonctions ou de classes</strong>. <strong>ES2015</strong> fournit du <em>Â« sucre syntaxique Â»</em> qui facilite considÃ©rablement la dÃ©finition de classes, comparÃ©e Ã  lâ€™approche traditionnelle en JavaScript.</p>

<blockquote>
  <p>Si tu viens dâ€™un autre langage, POO , voir le  mot clÃ© <code class="highlighter-rouge">Class</code> te fait peut-Ãªtre dire, â€œAh,ğŸŸğŸ˜† JavaScript est enfin un langage orientÃ© objet..â€ DÃ©trompe-toi , il lâ€™a toujours Ã©tÃ© , et mÃªme plus que <code class="highlighter-rouge">Java</code>. Brefâ€¦
Saches juste quâ€™en POO, on manipule des objets qui reprÃ©sentent des entitÃ©s de notre programme (des composants, des documents, des utilisateursâ€¦), et quâ€™une classe est en quelque sorte le plan de construction pour une catÃ©gorie dâ€™objets (et lâ€™usine qui les fabrique).</p>
</blockquote>

<p>Cette syntaxe est comparable Ã  celle trouvÃ©e dans de nombreux langages courants. Voici un exemple :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Account</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="na">loginState</span><span class="p">:</span> <span class="dl">'</span><span class="s1">logged-out</span><span class="dl">'</span> <span class="p">}</span>

  <span class="nx">render</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// â€¦</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>âš  Fait bien attention aux points suivants :</p>

<ul>
  <li>
    <p>Le mot-clÃ©  <code class="highlighter-rouge">class</code>  permet de dÃ©finir un <strong>corps de classe</strong>, dont les Ã©lÃ©ments (constructeur, mÃ©thodes, etc.) nâ€™ont pas besoin dâ€™Ãªtre sÃ©parÃ©s par des virgules, contrairement Ã  ce qui se passe dans les littÃ©raux objets.</p>
  </li>
  <li>
    <p>Il est facile de spÃ©cialiser une classe par hÃ©ritage Ã  lâ€™aide du mot-clÃ© <code class="highlighter-rouge">extends</code></p>
  </li>
  <li>
    <p>Le mot-clÃ©  <code class="highlighter-rouge">constructor</code>  permet de dÃ©finir le constructeur de la classe ; au sein du constructeur,  <code class="highlighter-rouge">super(â€¦)</code>  permet dâ€™appeler le constructeur hÃ©ritÃ©, ce qui est dâ€™ailleurs <strong>obligatoire</strong> si la classe en spÃ©cialise une autre avec <code class="highlighter-rouge">extends</code>  (et doit impÃ©rativement prÃ©cÃ©der toute manipulation de <code class="highlighter-rouge">this</code> ).</p>
  </li>
</ul>

<blockquote>
  <p>ğŸ“‘ <strong>Note bien ceci:</strong> si tu Ã©crit une classe qui en spÃ©cialise une autre avec  <code class="highlighter-rouge">extends</code> , et que ta classe a son propre constructeur, celui-ci doit impÃ©rativement appeler le constructeur parent avec  <code class="highlighter-rouge">super(â€¦)</code> , et ce avant de manipuler  <code class="highlighter-rouge">this</code>  de quelque faÃ§on que ce soit.
Câ€™est juste une obligation syntaxique dans la spec : ton code JavaScript <em>ne devrait pas Ãªtre valide sans cela</em>. En pratique, la plupart des moteurs JS (hors Babel, qui justement tourne Â« sous le capot Â» dans <strong>Create React App</strong> et dans la plupart des projets) attendront lâ€™invocation du  <code class="highlighter-rouge">new</code>  pour dÃ©tecter le souci, et lever une  <code class="highlighter-rouge">ReferenceError</code>  plutÃ´t quâ€™une  <code class="highlighter-rouge">SyntaxError</code>. Dans tous les cas, Ã§a ne marchera pas <em>in fine.</em></p>
</blockquote>

<ul>
  <li>Les mÃ©thodes doivent Ãªtre dÃ©clarÃ©es avec la nouvelle syntaxe de Â« mÃ©thodes concises Â», Ã©galement disponible dans les littÃ©raux objets :  <code class="highlighter-rouge">nom (paramÃ¨tres) { â€¦ }</code> , contrairement Ã  ce que lâ€™on faisait auparavant dans les littÃ©raux objets, comme par exemple   nom: <code class="highlighter-rouge">function (paramÃ¨tres) { â€¦ } </code>.</li>
</ul>

<p>Et parce que la Documentation on adore Ã§a ğŸ˜ , câ€™est <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Classes">par iciğŸ‘‰</a></p>

<h1 id="fonctions-flÃ©chÃ©es">Fonctions flÃ©chÃ©es</h1>

<blockquote>
  <p>Une syntaxe plus concise.</p>
</blockquote>

<p>Le premier avantage des fonctions flÃ©chÃ©es est <strong>la concision de leur syntaxe.</strong></p>

<p>Traditionnellement, une fonction se dÃ©clare avec le mot-clÃ©  <code class="highlighter-rouge">function</code>  suivi de la signature puis du bloc de fonction, au sein duquel tout  <code class="highlighter-rouge">return</code>  doit Ãªtre explicite. Par exemple :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">adults</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">minors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nx">people</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">adults</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="nx">minors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
   <span class="p">})</span>

<span class="nx">people</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">person</span><span class="p">.</span><span class="nx">firstName</span>
<span class="p">})</span>

</code></pre></div></div>
<p>Les fonctions flÃ©chÃ©es ne nÃ©cessitent pas de mot-clÃ© dÃ©claratif. Lorsquâ€™elles sont intÃ©gralement constituÃ©es dâ€™une expression Ã  renvoyer, les accolades du bloc de fonction peuvent Ãªtre omises,  ainsi que le mot-clÃ© <code class="highlighter-rouge">return</code> .</p>

<p>Entre la signature et le bloc ou lâ€™expression, on trouve une <em>fat arrow</em> (un nom bien naze!) , Ã  savoir  <code class="highlighter-rouge">=&gt;</code></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">adults</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">minors</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nx">people</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">person</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">&gt;=</span> <span class="mi">18</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">adults</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">minors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="nx">people</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">person</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">person</span><span class="p">.</span><span class="nx">firstName</span><span class="p">)</span>

</code></pre></div></div>
<p>Câ€™est une syntaxe raccourcie trÃ¨s pratique pour les <strong>prÃ©dicats</strong> (fonctions qui renvoient vrai ou faux selon leurs arguments, et qui sont par exemple passÃ©es aux mÃ©thodes <code class="highlighter-rouge">filter</code>, <code class="highlighter-rouge">every</code>  et  <code class="highlighter-rouge">some</code>) et les <strong>mappers</strong> (fonctions de transformation telles que celles passÃ©es Ã  <code class="highlighter-rouge">map</code>). Dans ce deuxiÃ¨me cas, elles seront par exemple trÃ¨s utiles pour Â« rÃ©duire le bruit Â» dans les mÃ©thodes  <code class="highlighter-rouge">render</code> de nos composants React.</p>

<h4 id="oui-mais-la-question-du-this">Oui, mais la question du <code class="highlighter-rouge">this</code></h4>

<p>Du fait quâ€™ historiquement, JavaScript ne proposait quâ€™une maniÃ¨re de dÃ©clarer des fonctions : le mot-clÃ©  <code class="highlighter-rouge">function</code>. Les fonctions ainsi dÃ©clarÃ©es avaient un comportement spÃ©cifique Ã  JavaScript, fondÃ© non pas sur lâ€™endroit de leur dÃ©claration dans le code, mais sur la syntaxe utilisÃ©e pour les appeler.  Cette syntaxe dÃ©terminait notamment, au sein de la fonction, la valeur de <code class="highlighter-rouge">this</code>.</p>

<p>Le fait de pouvoir appeler une fonction en contrÃ´lant le rÃ´le de <code class="highlighter-rouge">this</code> Ã  lâ€™intÃ©rieur a de nombreux avantages, mais comporte aussi un inconvÃ©nient : dans les fonctions de rappel (<em>callbacks</em>) notamment, on voulait souvent pouvoir continuer Ã  utiliser le <code class="highlighter-rouge">this</code>  en vigueur Â« Ã  la ligne du dessus Â», comme pour nâ€™importe quel identifiant ordinaire.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">ExtÃ©rieur</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">IntÃ©rieur</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">runGreet</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Ici, this.name est bien "IntÃ©rieur"</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Ici, this est soit lâ€™objet global (mode laxiste de JS),</span>
      <span class="c1">// soit null (mode strict de JS)</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">runGreet</span><span class="p">()</span>
</code></pre></div></div>
<p>Les fonctions flÃ©chÃ©es contournent ce problÃ¨me en ne redÃ©finissant aucun identifiant lors de leur invocation (pas mÃªme  <code class="highlighter-rouge">this</code> ).</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">ExtÃ©rieur</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">IntÃ©rieur</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">runGreet</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Ici, this.name est bien "IntÃ©rieur"</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// Ici, this nâ€™est pas redÃ©fini par la fonction,</span>
      <span class="c1">// car câ€™est une fonction flÃ©chÃ©eÂ : comme nâ€™importe</span>
      <span class="c1">// quel identifiant, il est donc recherchÃ© dans les</span>
      <span class="c1">// portÃ©es englobantes, et trouvÃ© au niveau de</span>
      <span class="c1">// runGreet, câ€™est donc aussi "IntÃ©rieur".</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">runGreet</span><span class="p">()</span>

</code></pre></div></div>
<p>Et cette capacitÃ© Ã  ne pas interfÃ©rer avec le <code class="highlighter-rouge">this</code>  en vigueur les rendra inestimables pour les mÃ©thodes  <code class="highlighter-rouge">render</code>  de nos composants Reactâ€¦!</p>

<h1 id="dÃ©structuration">DÃ©structuration</h1>

<p>La dÃ©structuration te permet dâ€™aller rapidement chercher plusieurs propriÃ©tÃ©s au sein dâ€™un objet, ou plusieurs cellules au sein de nâ€™importe quel objet itÃ©rable (comme un tableau) sans avoir Ã  multiplier les dÃ©clarations ou affectations.</p>

<p>Par exemple, au lieu de faire ceci :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ã€ l'ancienne</span>
<span class="kd">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">firstName</span>
<span class="kd">const</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">lastName</span>
<span class="kd">const</span> <span class="nx">onClick</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">onClick</span>
</code></pre></div></div>

<p>On peut simplement faire :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Avec une dÃ©structuration basÃ©e sur les noms</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">,</span> <span class="nx">onClick</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span>
</code></pre></div></div>
<p>Imaginons maintenant quâ€™on dÃ©coupe un texte Â« prÃ©nom nom Â» en deux, et quâ€™on veuille affecter les parties Ã  deux identifiants. Au lieu de faire :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Ã€ l'ancienne</span>
<span class="kd">const</span> <span class="nx">names</span> <span class="o">=</span> <span class="nx">fullName</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">firstName</span> <span class="o">=</span> <span class="nx">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="kd">const</span> <span class="nx">lastName</span> <span class="o">=</span> <span class="nx">names</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>
<p>On peut faire :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Avec une dÃ©structuration basÃ©e sur les positions</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fullName</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>
<p>Sympathique, non ? Il est possible dâ€™aller beaucoup plus loin evidemmentâ€¦</p>

<h1 id="modules-natifs-imports-et-exports">Modules natifs, imports et exports</h1>
<p>Nous dÃ©couperons notre application en modules, qui sont autant de fichiers sources sÃ©parÃ©s. Pour cela, nous aurons recours Ã  la syntaxe officielle des ES Modules. Nous rendrons visibles les parties de nos modules que nous souhaitons Ã  lâ€™aide dâ€™export  et nous irons chercher les parties qui nous intÃ©ressent dans dâ€™autres modules Ã  lâ€™aide dâ€™ import .</p>

<p>Voici un exemple de deux modules, le second utilisant le premier (ce sont deux fichiers diffÃ©rents, rassemblÃ©s ci-dessous pour plus de concision) :</p>

<p>// Au sein du fichier textUtils.js</p>

<p>export function countWords (text) {
  return text.split(/\W+/u).filter(Boolean).length
}</p>

<p>export function normalizeSpacing (text) {
  return text.replace(/\s+/u, â€˜ â€˜).trim()
}</p>

<p>// Au sein dâ€™un fichier main.js, dans le mÃªme rÃ©pertoire :</p>

<p>import { countWords } from â€˜./textUtilsâ€™</p>

<p>console.log(countWords(â€˜Hello world, this is nice!â€™))
Il est Ã©galement possible de dÃ©clarer un export Â« par dÃ©faut Â». Dans ce cas nous pouvons lâ€™importer sous le nom que lâ€™on veut, sans avoir Ã  recourir aux accolades :</p>

<p>// Dans le module exportateur, SuperComponent.js :</p>

<p>export default class SuperComponent {
  // â€¦
}</p>

<p>// Dans le module importateur, dans le mÃªme rÃ©pertoire :</p>

<p>import GreatComponent from â€˜./SuperComponentâ€™
DÃ©sormais, vous avez tous les Ã©lÃ©ments pour Ã©crire vos composants React de faÃ§on moderne !</p>

<p>#</p>

:ET